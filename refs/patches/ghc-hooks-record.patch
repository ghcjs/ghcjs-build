diff --git a/compiler/cmm/CLabel.hs b/compiler/cmm/CLabel.hs
index 1b86f3d..cd1da99 100644
--- a/compiler/cmm/CLabel.hs
+++ b/compiler/cmm/CLabel.hs
@@ -106,7 +106,7 @@ module CLabel (
 
 import IdInfo
 import BasicTypes
-import Packages
+import PackageState (isDllName)
 import Module
 import Name
 import Unique
diff --git a/compiler/deSugar/DsForeign.lhs b/compiler/deSugar/DsForeign.lhs
index 1053b91..c7cc13f 100644
--- a/compiler/deSugar/DsForeign.lhs
+++ b/compiler/deSugar/DsForeign.lhs
@@ -6,7 +6,13 @@
 Desugaring foreign declarations (see also DsCCall).
 
 \begin{code}
-module DsForeign ( dsForeigns ) where
+module DsForeign ( dsForeigns
+                 , dsForeigns'
+                 , dsFImport, dsCImport, dsFCall, dsPrimCall
+                 , dsFExport, dsFExportDynamic, mkFExportCBits
+                 , toCType
+                 , foreignExportInitialiser
+                 ) where
 
 #include "HsVersions.h"
 import TcRnMonad        -- temp
@@ -48,6 +54,7 @@ import Config
 import OrdList
 import Pair
 import Util
+import Hooks
 
 import Data.Maybe
 import Data.List
@@ -72,9 +79,13 @@ type Binding = (Id, CoreExpr)   -- No rec/nonrec structure;
 
 dsForeigns :: [LForeignDecl Id]
            -> DsM (ForeignStubs, OrdList Binding)
-dsForeigns []
+dsForeigns fos = getHooked dsForeignsHook dsForeigns' >>= ($ fos)
+
+dsForeigns' :: [LForeignDecl Id]
+            -> DsM (ForeignStubs, OrdList Binding)
+dsForeigns' []
   = return (NoStubs, nilOL)
-dsForeigns fos = do
+dsForeigns' fos = do
     fives <- mapM do_ldecl fos
     let
         (hs, cs, idss, bindss) = unzip4 fives
diff --git a/compiler/deSugar/DsMonad.lhs-boot b/compiler/deSugar/DsMonad.lhs-boot
index e69de29..2c6b128 100644
--- a/compiler/deSugar/DsMonad.lhs-boot
+++ b/compiler/deSugar/DsMonad.lhs-boot
@@ -0,0 +1,10 @@
+\begin{code}
+module DsMonad (DsM) where
+
+import TcRnTypes
+
+data DsGblEnv
+data DsLclEnv
+type DsM result = TcRnIf DsGblEnv DsLclEnv result
+
+\end{code}
\ No newline at end of file
diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index bfcbb87..b92cc27 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -134,6 +134,7 @@ Library
         Demand
         Exception
         GhcMonad
+        Hooks
         Id
         IdInfo
         Literal
@@ -292,6 +293,7 @@ Library
         InteractiveEvalTypes
         PackageConfig
         Packages
+        PackageState
         PlatformConstants
         PprTyThing
         StaticFlags
diff --git a/compiler/ghc.mk b/compiler/ghc.mk
index 770f580..ec8f3a9 100644
--- a/compiler/ghc.mk
+++ b/compiler/ghc.mk
@@ -439,7 +439,7 @@ compiler_stage3_SplitObjs = NO
 # We therefore need to split some of the modules off into a separate
 # DLL. This clump are the modules reachable from DynFlags:
 compiler_stage2_dll0_START_MODULE = DynFlags
-compiler_stage2_dll0_MODULES = Annotations Avail Bag BasicTypes Binary Bitmap BlockId BreakArray BufWrite ByteCodeAsm ByteCodeInstr ByteCodeItbls ByteCodeLink CLabel Class CmdLineParser Cmm CmmCallConv CmmExpr CmmInfo CmmMachOp CmmNode CmmType CmmUtils CoAxiom CodeGen.Platform CodeGen.Platform.ARM CodeGen.Platform.NoRegs CodeGen.Platform.PPC CodeGen.Platform.PPC_Darwin CodeGen.Platform.SPARC CodeGen.Platform.X86 CodeGen.Platform.X86_64 Coercion Config Constants CoreArity CoreFVs CoreSubst CoreSyn CoreTidy CoreUnfold CoreUtils CostCentre DataCon Demand Digraph DriverPhases DynFlags Encoding ErrUtils Exception FamInstEnv FastBool FastFunctions FastMutInt FastString FastTypes Fingerprint FiniteMap ForeignCall Hoopl Hoopl.Dataflow HsBinds HsDecls HsDoc HsExpr HsImpExp HsLit HsPat HsSyn HsTypes HsUtils HscTypes Id IdInfo IfaceSyn IfaceType InstEnv InteractiveEvalTypes Kind ListSetOps Literal Maybes MkCore MkGraph MkId Module MonadUtils Name NameEnv NameSet ObjLink OccName OccurAnal OptCoercion OrdList Outputable PackageConfig Packages Pair Panic Platform PlatformConstants PprCmm PprCmmDecl PprCmmExpr PprCore PrelNames PrelRules Pretty PrimOp RdrName Reg RegClass Rules SMRep Serialized SrcLoc StaticFlags StgCmmArgRep StgCmmClosure StgCmmEnv StgCmmLayout StgCmmMonad StgCmmProf StgCmmTicky StgCmmUtils StgSyn Stream StringBuffer TcEvidence TcType TrieMap TyCon Type TypeRep TysPrim TysWiredIn Unify UniqFM UniqSet UniqSupply Unique Util Var VarEnv VarSet
+compiler_stage2_dll0_MODULES = Annotations Avail Bag BasicTypes Binary Bitmap BlockId BreakArray BufWrite ByteCodeAsm ByteCodeInstr ByteCodeItbls ByteCodeLink CLabel Class CmdLineParser Cmm CmmCallConv CmmExpr CmmInfo CmmMachOp CmmNode CmmType CmmUtils CoAxiom CodeGen.Platform CodeGen.Platform.ARM CodeGen.Platform.NoRegs CodeGen.Platform.PPC CodeGen.Platform.PPC_Darwin CodeGen.Platform.SPARC CodeGen.Platform.X86 CodeGen.Platform.X86_64 Coercion Config Constants CoreArity CoreFVs CoreSubst CoreSyn CoreTidy CoreUnfold CoreUtils CostCentre DataCon Demand Digraph DriverPhases DynFlags Encoding ErrUtils Exception FamInstEnv FastBool FastFunctions FastMutInt FastString FastTypes Fingerprint FiniteMap ForeignCall Hooks Hoopl Hoopl.Dataflow HsBinds HsDecls HsDoc HsExpr HsImpExp HsLit HsPat HsSyn HsTypes HsUtils HscTypes Id IdInfo IfaceSyn IfaceType InstEnv InteractiveEvalTypes Kind ListSetOps Literal Maybes MkCore MkGraph MkId Module MonadUtils Name NameEnv NameSet ObjLink OccName OccurAnal OptCoercion OrdList Outputable PackageConfig PackageState Pair Panic Platform PlatformConstants PprCmm PprCmmDecl PprCmmExpr PprCore PrelNames PrelRules Pretty PrimOp RdrName Reg RegClass Rules SMRep Serialized SrcLoc StaticFlags StgCmmArgRep StgCmmClosure StgCmmEnv StgCmmLayout StgCmmMonad StgCmmProf StgCmmTicky StgCmmUtils StgSyn Stream StringBuffer TcEvidence TcType TrieMap TyCon Type TypeRep TysPrim TysWiredIn Unify UniqFM UniqSet UniqSupply Unique Util Var VarEnv VarSet
 
 compiler_stage2_dll0_HS_OBJS = \
     $(patsubst %,compiler/stage2/build/%.$(dyn_osuf),$(subst .,/,$(compiler_stage2_dll0_MODULES)))
diff --git a/compiler/ghci/Linker.lhs b/compiler/ghci/Linker.lhs
index 192df2e..34314b4 100644
--- a/compiler/ghci/Linker.lhs
+++ b/compiler/ghci/Linker.lhs
@@ -18,7 +18,10 @@ module Linker ( HValue, getHValue, showLinkerState,
                 linkPackages,initDynLinker,linkModule,
 
                 -- Saving/restoring globals
-                PersistentLinkerState, saveLinkerGlobals, restoreLinkerGlobals
+                PersistentLinkerState, saveLinkerGlobals, restoreLinkerGlobals,
+                -- Hook for customizing library locations
+                locateLib', LibrarySpec(..),
+                searchForLibUsingGcc
         ) where
 
 #include "HsVersions.h"
@@ -53,6 +56,7 @@ import Config
 import Platform
 import SysTools
 import PrelNames
+import Hooks
 
 -- Standard libraries
 import Control.Monad
@@ -1171,7 +1175,10 @@ loadFrameworks platform pkg
 -- standard system search path.
 
 locateLib :: DynFlags -> Bool -> [FilePath] -> String -> IO LibrarySpec
-locateLib dflags is_hs dirs lib
+locateLib dflags = lookupHook locateLibHook locateLib' dflags dflags
+
+locateLib' :: DynFlags -> Bool -> [FilePath] -> String -> IO LibrarySpec
+locateLib' dflags is_hs dirs lib
   | not is_hs
     -- For non-Haskell libraries (e.g. gmp, iconv):
     --   first look in library-dirs for a dynamic library (libfoo.so)
diff --git a/compiler/ghci/Linker.lhs-boot b/compiler/ghci/Linker.lhs-boot
index e69de29..d54fa9b 100644
--- a/compiler/ghci/Linker.lhs-boot
+++ b/compiler/ghci/Linker.lhs-boot
@@ -0,0 +1,5 @@
+\begin{code}
+module Linker where
+
+data LibrarySpec
+\end{code}
\ No newline at end of file
diff --git a/compiler/iface/LoadIface.lhs b/compiler/iface/LoadIface.lhs
index ac0b09c..0fc8e68 100644
--- a/compiler/iface/LoadIface.lhs
+++ b/compiler/iface/LoadIface.lhs
@@ -59,6 +59,7 @@ import Panic
 import Util
 import FastString
 import Fingerprint
+import Hooks
 
 import Control.Monad
 import Data.IORef
@@ -516,7 +517,9 @@ findAndReadIface doc_str mod hi_boot_file
 
        -- Check for GHC.Prim, and return its static interface
        if mod == gHC_PRIM
-           then return (Succeeded (ghcPrimIface,
+           then do
+               iface <- getHooked ghcPrimIfaceHook ghcPrimIface
+               return (Succeeded (iface,
                                    "<built in interface for GHC.Prim>"))
            else do
                dflags <- getDynFlags
diff --git a/compiler/main/DriverPipeline.hs b/compiler/main/DriverPipeline.hs
index 7c5bc90..17a054e 100644
--- a/compiler/main/DriverPipeline.hs
+++ b/compiler/main/DriverPipeline.hs
@@ -23,6 +23,14 @@ module DriverPipeline (
    compileOne, compileOne',
    link,
 
+        -- Hook to override behaviour for each phase
+   PhasePlus(..), CompPipeline(..), PipeEnv(..), PipeState(..),
+   phaseOutputFilename, getPipeState, getPipeEnv,
+   hscPostBackendPhase, getLocation, setModLocation, setDynFlags,
+   runPhase,
+   linkBinary'', exeFileName,
+   mkExtraObjToLinkIntoBinary, mkNoteObjsToLinkIntoBinary,
+   maybeCreateManifest, runPhase_MoveBinary
   ) where
 
 #include "HsVersions.h"
@@ -31,7 +39,7 @@ import Packages
 import HeaderInfo
 import DriverPhases
 import SysTools
-import HscMain
+import HscMain hiding ( Hsc )
 import Finder
 import HscTypes
 import Outputable
@@ -52,6 +60,7 @@ import LlvmCodeGen      ( llvmFixupAsm )
 import MonadUtils
 import Platform
 import TcRnTypes
+import Hooks
 
 import Exception
 import Data.IORef       ( readIORef )
@@ -728,7 +737,7 @@ pipeLoop phase input_fn = do
    _
      -> do liftIO $ debugTraceMsg dflags 4
                                   (ptext (sLit "Running phase") <+> ppr phase)
-           (next_phase, output_fn) <- runPhase phase input_fn dflags
+           (next_phase, output_fn) <- runHookedPhase phase input_fn dflags
            r <- pipeLoop next_phase output_fn
            case phase of
                HscOut {} ->
@@ -741,6 +750,11 @@ pipeLoop phase input_fn = do
                    return ()
            return r
 
+runHookedPhase :: PhasePlus -> FilePath -> DynFlags 
+               -> CompPipeline (PhasePlus, FilePath)
+runHookedPhase pp input dflags =
+  lookupHook runPhaseHook runPhase dflags pp input dflags
+
 -- -----------------------------------------------------------------------------
 -- In each phase, we need to know into what filename to generate the
 -- output.  All the logic about which filenames we generate output
@@ -1782,7 +1796,11 @@ linkBinary :: DynFlags -> [FilePath] -> [PackageId] -> IO ()
 linkBinary = linkBinary' False
 
 linkBinary' :: Bool -> DynFlags -> [FilePath] -> [PackageId] -> IO ()
-linkBinary' staticLink dflags o_files dep_packages = do
+linkBinary' staticLink dflags =
+  lookupHook linkBinaryHook linkBinary'' dflags staticLink dflags
+
+linkBinary'' :: Bool -> DynFlags -> [FilePath] -> [PackageId] -> IO ()
+linkBinary'' staticLink dflags o_files dep_packages = do
     let platform = targetPlatform dflags
         mySettings = settings dflags
         verbFlags = getVerbFlags dflags
diff --git a/compiler/main/DriverPipeline.hs-boot b/compiler/main/DriverPipeline.hs-boot
index e69de29..07838bd 100644
--- a/compiler/main/DriverPipeline.hs-boot
+++ b/compiler/main/DriverPipeline.hs-boot
@@ -0,0 +1,6 @@
+module DriverPipeline where
+
+data PipeEnv
+data PipeState
+newtype CompPipeline a = P { unP :: PipeEnv -> PipeState -> IO (PipeState, a) }
+data PhasePlus
\ No newline at end of file
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 4254efd..6be5aad 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -143,7 +143,7 @@ import PlatformConstants
 import Module
 import PackageConfig
 import {-# SOURCE #-} PrelNames ( mAIN )
-import {-# SOURCE #-} Packages (PackageState)
+import {-# SOURCE #-} PackageState (PackageState)
 import DriverPhases     ( Phase(..), phaseInputExt )
 import Config
 import CmdLineParser
@@ -167,6 +167,7 @@ import Control.Monad
 
 import Data.Bits
 import Data.Char
+import Data.Dynamic
 import Data.Int
 import Data.List
 import Data.Map (Map)
@@ -664,6 +665,8 @@ data DynFlags = DynFlags {
   -- Plugins
   pluginModNames        :: [ModuleName],
   pluginModNameOpts     :: [(ModuleName,String)],
+  hooks                 :: Dynamic,     -- ^ use the functions in Hooks to query this
+
 
   --  For ghc -M
   depMakefile           :: FilePath,
@@ -1303,6 +1306,7 @@ defaultDynFlags mySettings =
 
         pluginModNames          = [],
         pluginModNameOpts       = [],
+        hooks                   = toDyn (),
 
         outputFile              = Nothing,
         dynOutputFile           = Nothing,
diff --git a/compiler/main/Hooks.lhs b/compiler/main/Hooks.lhs
index e69de29..47584f3 100644
--- a/compiler/main/Hooks.lhs
+++ b/compiler/main/Hooks.lhs
@@ -0,0 +1,78 @@
+\section[Hooks]{Low level API hooks}
+
+\begin{code}
+module Hooks ( Hooks (..)
+             , lookupHook
+             , getHooked
+             , setHooks
+             , getHooks
+             ) where
+
+import DynFlags
+import HsTypes
+import Name
+import {-# SOURCE #-} DriverPipeline
+import Module
+import HscTypes
+import HsDecls
+import HsBinds
+import {-# SOURCE #-} DsMonad
+import OrdList
+import Id
+import TcRnTypes
+import Bag
+import {-# SOURCE #-} HscMain
+import RdrName
+import {-# SOURCE #-} Linker
+import PackageConfig
+import CoreSyn
+
+import Data.Dynamic
+import Data.Maybe
+\end{code}
+
+%************************************************************************
+%*                                                                      *
+\subsection{Hooks}
+%*                                                                      *
+%************************************************************************
+
+\begin{code}
+
+-- | Hooks can be used by GHC API clients to replace parts of
+--   the compiler pipeline. If a hook is not installed, GHC
+--   uses the default built-in behaviour
+
+emptyHooks :: Hooks
+emptyHooks = Hooks Nothing Nothing Nothing Nothing Nothing Nothing
+                   Nothing Nothing Nothing Nothing Nothing Nothing
+
+data Hooks = Hooks
+  { dsForeignsHook        :: Maybe ([LForeignDecl Id] -> DsM (ForeignStubs, OrdList (Id, CoreExpr)))
+  , tcForeignImportsHook  :: Maybe ([LForeignDecl Name] -> TcM ([Id], [LForeignDecl Id], Bag GlobalRdrElt))
+  , tcForeignExportsHook  :: Maybe ([LForeignDecl Name] -> TcM (LHsBinds TcId, [LForeignDecl TcId], Bag GlobalRdrElt))
+  , packageHsLibsHook     :: Maybe (DynFlags -> PackageConfig -> [String])
+  , locateLibHook         :: Maybe (DynFlags -> Bool -> [FilePath] -> String -> IO LibrarySpec)
+  , hscFrontendHook       :: Maybe (ModSummary -> Hsc TcGblEnv)
+  , hscCompileOneShotHook :: Maybe (HscEnv -> FilePath -> ModSummary -> SourceModified -> IO HscStatus)
+  , ghcPrimIfaceHook      :: Maybe ModIface
+  , runPhaseHook          :: Maybe (PhasePlus -> FilePath -> DynFlags -> CompPipeline (PhasePlus, FilePath))
+  , linkBinaryHook        :: Maybe (Bool -> DynFlags -> [FilePath] -> [PackageId] -> IO ())
+  , linkDynLibHook        :: Maybe (DynFlags -> [String] -> [PackageId] -> IO ())
+  , runQuasiQuoteHook     :: Maybe (HsQuasiQuote Name -> RnM (HsQuasiQuote Name))
+  } deriving Typeable
+
+getHooked :: (Functor f, HasDynFlags f) => (Hooks -> Maybe a) -> a -> f a
+getHooked hook def = fmap (lookupHook hook def) getDynFlags
+
+lookupHook :: (Hooks -> Maybe a) -> a -> DynFlags -> a
+lookupHook hook def = fromMaybe def . hook . getHooks
+
+setHooks :: Hooks -> DynFlags -> DynFlags
+setHooks h dflags = dflags { hooks = toDyn h }
+
+getHooks :: DynFlags -> Hooks
+getHooks dflags = fromDyn (hooks dflags) emptyHooks
+
+\end{code}
+
diff --git a/compiler/main/HscMain.hs b/compiler/main/HscMain.hs
index ad1b7c5..95e73d2 100644
--- a/compiler/main/HscMain.hs
+++ b/compiler/main/HscMain.hs
@@ -71,6 +71,12 @@ module HscMain
     , hscTcExpr, hscImport, hscKcType
     , hscCompileCoreExpr
 #endif
+    -- * Hooks and low-level exports for hooks
+    , Hsc(..), runHsc
+    , hscParse', hscSimplify', hscDesugar', tcRnModule'
+    , hscSimpleIface', hscNormalIface'
+    , oneShotMsg
+    , hscFileFrontEnd, genericHscFrontend, dumpIfaceStats
     ) where
 
 #ifdef GHCI
@@ -128,6 +134,7 @@ import NameSet          ( emptyNameSet )
 import InstEnv
 import FamInstEnv
 import Fingerprint      ( Fingerprint )
+import Hooks
 
 import DynFlags
 import ErrUtils
@@ -603,23 +610,35 @@ genericHscCompileGetFrontendResult always_do_basic_recompilation_check m_tc_resu
                         return $ Right (tc_result, mb_old_hash)
 
 genericHscFrontend :: ModSummary -> Hsc TcGblEnv
-genericHscFrontend mod_summary
+genericHscFrontend mod_summary =
+  getHooked hscFrontendHook genericHscFrontend' >>= ($ mod_summary)
+
+genericHscFrontend' :: ModSummary -> Hsc TcGblEnv
+genericHscFrontend' mod_summary
     | ExtCoreFile <- ms_hsc_src mod_summary =
         panic "GHC does not currently support reading External Core files"
-    | otherwise = do
+    | otherwise =
         hscFileFrontEnd mod_summary
 
 --------------------------------------------------------------
 -- Compilers
 --------------------------------------------------------------
 
--- Compile Haskell, boot and extCore in OneShot mode.
 hscCompileOneShot :: HscEnv
                   -> FilePath
                   -> ModSummary
                   -> SourceModified
                   -> IO HscStatus
-hscCompileOneShot hsc_env extCore_filename mod_summary src_changed
+hscCompileOneShot env =
+  lookupHook hscCompileOneShotHook hscCompileOneShot' (hsc_dflags env) env
+
+-- Compile Haskell, boot and extCore in OneShot mode.
+hscCompileOneShot' :: HscEnv
+                   -> FilePath
+                   -> ModSummary
+                   -> SourceModified
+                   -> IO HscStatus
+hscCompileOneShot' hsc_env extCore_filename mod_summary src_changed
   = do
     -- One-shot mode needs a knot-tying mutable variable for interface
     -- files. See TcRnTypes.TcGblEnv.tcg_type_env_var.
diff --git a/compiler/main/HscMain.hs-boot b/compiler/main/HscMain.hs-boot
index e69de29..843713e 100644
--- a/compiler/main/HscMain.hs-boot
+++ b/compiler/main/HscMain.hs-boot
@@ -0,0 +1,7 @@
+module HscMain where
+
+import ErrUtils
+import HscTypes
+
+newtype Hsc a = Hsc (HscEnv -> WarningMessages -> IO (a, WarningMessages))
+data HscStatus
diff --git a/compiler/main/HscTypes.lhs b/compiler/main/HscTypes.lhs
index 33dbba2..fb6b366 100644
--- a/compiler/main/HscTypes.lhs
+++ b/compiler/main/HscTypes.lhs
@@ -141,7 +141,9 @@ import TyCon
 import CoAxiom
 import DataCon
 import PrelNames        ( gHC_PRIM, ioTyConName, printName )
-import Packages hiding  ( Version(..) )
+import PackageConfig    ( packageConfigId )
+import PackageState     ( lookupModuleInAllPackages ) 
+import Distribution.InstalledPackageInfo ( exposed )
 import DynFlags
 import DriverPhases
 import BasicTypes
diff --git a/compiler/main/PackageState.lhs b/compiler/main/PackageState.lhs
index e69de29..5478596 100644
--- a/compiler/main/PackageState.lhs
+++ b/compiler/main/PackageState.lhs
@@ -0,0 +1,186 @@
+%
+% (c) The University of Glasgow, 2006
+%
+\begin{code}
+-- | The PackagesState
+--
+-- Split off from DynFlags so that DynFlags can import this without depending
+-- on the entire Hooks machinery.
+module PackageState (
+        module PackageConfig,
+
+        -- * The PackageConfigMap
+        PackageConfigMap, emptyPackageConfigMap, lookupPackage,
+        extendPackageConfigMap,
+
+        -- * Reading the package config, and processing cmdline args
+        PackageState(..), InstalledPackageIdMap, InstalledPackageIndex,
+        getPackageDetails,
+        lookupModuleInAllPackages, lookupModuleWithSuggestions,
+
+        -- * Utils
+        isDllName
+    )
+where
+
+#include "HsVersions.h"
+
+import PackageConfig
+import Module
+import UniqFM
+import Maybes
+import DynFlags
+import Name             ( Name, nameModule_maybe )
+import Panic
+import Util
+
+import Distribution.Package hiding (PackageId,depends)
+
+import Data.List
+import Data.Map (Map)
+import qualified Data.Set as Set
+
+-- ---------------------------------------------------------------------------
+-- The Package state
+
+-- | Package state is all stored in 'DynFlags', including the details of
+-- all packages, which packages are exposed, and which modules they
+-- provide.
+--
+-- The package state is computed by 'initPackages', and kept in DynFlags.
+--
+--   * @-package <pkg>@ causes @<pkg>@ to become exposed, and all other packages
+--      with the same name to become hidden.
+--
+--   * @-hide-package <pkg>@ causes @<pkg>@ to become hidden.
+--
+--   * Let @exposedPackages@ be the set of packages thus exposed.
+--     Let @depExposedPackages@ be the transitive closure from @exposedPackages@ of
+--     their dependencies.
+--
+--   * When searching for a module from an preload import declaration,
+--     only the exposed modules in @exposedPackages@ are valid.
+--
+--   * When searching for a module from an implicit import, all modules
+--     from @depExposedPackages@ are valid.
+--
+--   * When linking in a compilation manager mode, we link in packages the
+--     program depends on (the compiler knows this list by the
+--     time it gets to the link step).  Also, we link in all packages
+--     which were mentioned with preload @-package@ flags on the command-line,
+--     or are a transitive dependency of same, or are \"base\"\/\"rts\".
+--     The reason for this is that we might need packages which don't
+--     contain any Haskell modules, and therefore won't be discovered
+--     by the normal mechanism of dependency tracking.
+
+-- Notes on DLLs
+-- ~~~~~~~~~~~~~
+-- When compiling module A, which imports module B, we need to
+-- know whether B will be in the same DLL as A.
+--      If it's in the same DLL, we refer to B_f_closure
+--      If it isn't, we refer to _imp__B_f_closure
+-- When compiling A, we record in B's Module value whether it's
+-- in a different DLL, by setting the DLL flag.
+
+data PackageState = PackageState {
+  pkgIdMap              :: PackageConfigMap, -- PackageId   -> PackageConfig
+        -- The exposed flags are adjusted according to -package and
+        -- -hide-package flags, and -ignore-package removes packages.
+
+  preloadPackages      :: [PackageId],
+        -- The packages we're going to link in eagerly.  This list
+        -- should be in reverse dependency order; that is, a package
+        -- is always mentioned before the packages it depends on.
+
+  moduleToPkgConfAll    :: UniqFM [(PackageConfig,Bool)], -- ModuleEnv mapping
+        -- Derived from pkgIdMap.
+        -- Maps Module to (pkgconf,exposed), where pkgconf is the
+        -- PackageConfig for the package containing the module, and
+        -- exposed is True if the package exposes that module.
+
+  installedPackageIdMap :: InstalledPackageIdMap
+  }
+
+-- | A PackageConfigMap maps a 'PackageId' to a 'PackageConfig'
+type PackageConfigMap = UniqFM PackageConfig
+
+type InstalledPackageIdMap = Map InstalledPackageId PackageId
+
+type InstalledPackageIndex = Map InstalledPackageId PackageConfig
+
+emptyPackageConfigMap :: PackageConfigMap
+emptyPackageConfigMap = emptyUFM
+
+-- | Find the package we know about with the given id (e.g. \"foo-1.0\"), if any
+lookupPackage :: PackageConfigMap -> PackageId -> Maybe PackageConfig
+lookupPackage = lookupUFM
+
+extendPackageConfigMap
+   :: PackageConfigMap -> [PackageConfig] -> PackageConfigMap
+extendPackageConfigMap pkg_map new_pkgs
+  = foldl add pkg_map new_pkgs
+  where add pkg_map p = addToUFM pkg_map (packageConfigId p) p
+
+-- | Looks up the package with the given id in the package state, panicing if it is
+-- not found
+getPackageDetails :: PackageState -> PackageId -> PackageConfig
+getPackageDetails ps pid = expectJust "getPackageDetails" (lookupPackage (pkgIdMap ps) pid)
+
+-- -----------------------------------------------------------------------------
+-- Package Utils
+
+-- | Takes a 'Module', and if the module is in a package returns
+-- @(pkgconf, exposed)@ where pkgconf is the PackageConfig for that package,
+-- and exposed is @True@ if the package exposes the module.
+lookupModuleInAllPackages :: DynFlags -> ModuleName -> [(PackageConfig,Bool)]
+lookupModuleInAllPackages dflags m
+  = case lookupModuleWithSuggestions dflags m of
+      Right pbs -> pbs
+      Left  _   -> []
+
+lookupModuleWithSuggestions
+  :: DynFlags -> ModuleName
+  -> Either [Module] [(PackageConfig,Bool)]
+         -- Lookup module in all packages
+         -- Right pbs   =>   found in pbs
+         -- Left  ms    =>   not found; but here are sugestions
+lookupModuleWithSuggestions dflags m
+  = case lookupUFM (moduleToPkgConfAll pkg_state) m of
+        Nothing -> Left suggestions
+        Just ps -> Right ps
+  where
+    pkg_state = pkgState dflags
+    suggestions
+      | gopt Opt_HelpfulErrors dflags = fuzzyLookup (moduleNameString m) all_mods
+      | otherwise                     = []
+
+    all_mods :: [(String, Module)]     -- All modules
+    all_mods = [ (moduleNameString mod_nm, mkModule pkg_id mod_nm)
+               | pkg_config <- eltsUFM (pkgIdMap pkg_state)
+               , let pkg_id = packageConfigId pkg_config
+               , mod_nm <- exposedModules pkg_config ]
+
+
+-- -----------------------------------------------------------------------------
+
+-- | Will the 'Name' come from a dynamically linked library?
+isDllName :: DynFlags -> PackageId -> Module -> Name -> Bool
+-- Despite the "dll", I think this function just means that
+-- the synbol comes from another dynamically-linked package,
+-- and applies on all platforms, not just Windows
+isDllName dflags this_pkg this_mod name
+  | gopt Opt_Static dflags = False
+  | Just mod <- nameModule_maybe name
+    = if modulePackageId mod /= this_pkg
+      then True
+      else case dllSplit dflags of
+           Nothing -> False
+           Just ss ->
+               let findMod m = let modStr = moduleNameString (moduleName m)
+                               in case find (modStr `Set.member`) ss of
+                                  Just i -> i
+                                  Nothing -> panic ("Can't find " ++ modStr ++ "in DLL split")
+               in findMod mod /= findMod this_mod
+       
+  | otherwise = False  -- no, it is not even an external name
+\end{code}
diff --git a/compiler/main/PackageState.lhs-boot b/compiler/main/PackageState.lhs-boot
index e69de29..149dcbc 100644
--- a/compiler/main/PackageState.lhs-boot
+++ b/compiler/main/PackageState.lhs-boot
@@ -0,0 +1,4 @@
+\begin{code}
+module PackageState where
+data PackageState
+\end{code}
diff --git a/compiler/main/Packages.lhs b/compiler/main/Packages.lhs
index fb832ff..85ba7cc 100644
--- a/compiler/main/Packages.lhs
+++ b/compiler/main/Packages.lhs
@@ -5,16 +5,11 @@
 -- | Package manipulation
 module Packages (
         module PackageConfig,
-
-        -- * The PackageConfigMap
-        PackageConfigMap, emptyPackageConfigMap, lookupPackage,
-        extendPackageConfigMap, dumpPackages,
+        module PackageState,
 
         -- * Reading the package config, and processing cmdline args
-        PackageState(..),
         initPackages,
-        getPackageDetails,
-        lookupModuleInAllPackages, lookupModuleWithSuggestions,
+        dumpPackages,
 
         -- * Inspecting the set of packages in scope
         getPackageIncludePath,
@@ -28,23 +23,24 @@ module Packages (
         collectIncludeDirs, collectLibraryPaths, collectLinkOpts,
         packageHsLibs,
 
-        -- * Utils
-        isDllName
+        -- * Hook for customizing library filenames
+        packageHsLibs',
     )
 where
 
 #include "HsVersions.h"
 
 import PackageConfig
+import PackageState
 import DynFlags
 import Config           ( cProjectVersion )
-import Name             ( Name, nameModule_maybe )
 import UniqFM
 import Module
 import Util
 import Panic
 import Outputable
 import Maybes
+import Hooks
 
 import System.Environment ( getEnv )
 import Distribution.InstalledPackageInfo
@@ -65,92 +61,6 @@ import qualified Data.Map as Map
 import qualified FiniteMap as Map
 import qualified Data.Set as Set
 
--- ---------------------------------------------------------------------------
--- The Package state
-
--- | Package state is all stored in 'DynFlags', including the details of
--- all packages, which packages are exposed, and which modules they
--- provide.
---
--- The package state is computed by 'initPackages', and kept in DynFlags.
---
---   * @-package <pkg>@ causes @<pkg>@ to become exposed, and all other packages
---      with the same name to become hidden.
---
---   * @-hide-package <pkg>@ causes @<pkg>@ to become hidden.
---
---   * Let @exposedPackages@ be the set of packages thus exposed.
---     Let @depExposedPackages@ be the transitive closure from @exposedPackages@ of
---     their dependencies.
---
---   * When searching for a module from an preload import declaration,
---     only the exposed modules in @exposedPackages@ are valid.
---
---   * When searching for a module from an implicit import, all modules
---     from @depExposedPackages@ are valid.
---
---   * When linking in a compilation manager mode, we link in packages the
---     program depends on (the compiler knows this list by the
---     time it gets to the link step).  Also, we link in all packages
---     which were mentioned with preload @-package@ flags on the command-line,
---     or are a transitive dependency of same, or are \"base\"\/\"rts\".
---     The reason for this is that we might need packages which don't
---     contain any Haskell modules, and therefore won't be discovered
---     by the normal mechanism of dependency tracking.
-
--- Notes on DLLs
--- ~~~~~~~~~~~~~
--- When compiling module A, which imports module B, we need to
--- know whether B will be in the same DLL as A.
---      If it's in the same DLL, we refer to B_f_closure
---      If it isn't, we refer to _imp__B_f_closure
--- When compiling A, we record in B's Module value whether it's
--- in a different DLL, by setting the DLL flag.
-
-data PackageState = PackageState {
-  pkgIdMap              :: PackageConfigMap, -- PackageId   -> PackageConfig
-        -- The exposed flags are adjusted according to -package and
-        -- -hide-package flags, and -ignore-package removes packages.
-
-  preloadPackages      :: [PackageId],
-        -- The packages we're going to link in eagerly.  This list
-        -- should be in reverse dependency order; that is, a package
-        -- is always mentioned before the packages it depends on.
-
-  moduleToPkgConfAll    :: UniqFM [(PackageConfig,Bool)], -- ModuleEnv mapping
-        -- Derived from pkgIdMap.
-        -- Maps Module to (pkgconf,exposed), where pkgconf is the
-        -- PackageConfig for the package containing the module, and
-        -- exposed is True if the package exposes that module.
-
-  installedPackageIdMap :: InstalledPackageIdMap
-  }
-
--- | A PackageConfigMap maps a 'PackageId' to a 'PackageConfig'
-type PackageConfigMap = UniqFM PackageConfig
-
-type InstalledPackageIdMap = Map InstalledPackageId PackageId
-
-type InstalledPackageIndex = Map InstalledPackageId PackageConfig
-
-emptyPackageConfigMap :: PackageConfigMap
-emptyPackageConfigMap = emptyUFM
-
--- | Find the package we know about with the given id (e.g. \"foo-1.0\"), if any
-lookupPackage :: PackageConfigMap -> PackageId -> Maybe PackageConfig
-lookupPackage = lookupUFM
-
-extendPackageConfigMap
-   :: PackageConfigMap -> [PackageConfig] -> PackageConfigMap
-extendPackageConfigMap pkg_map new_pkgs
-  = foldl add pkg_map new_pkgs
-  where add pkg_map p = addToUFM pkg_map (packageConfigId p) p
-
--- | Looks up the package with the given id in the package state, panicing if it is
--- not found
-getPackageDetails :: PackageState -> PackageId -> PackageConfig
-getPackageDetails ps pid = expectJust "getPackageDetails" (lookupPackage (pkgIdMap ps) pid)
-
 -- ----------------------------------------------------------------------------
 -- Loading the package db files and building up the package state
 
@@ -882,7 +792,11 @@ collectLinkOpts dflags ps =
     )
 
 packageHsLibs :: DynFlags -> PackageConfig -> [String]
-packageHsLibs dflags p = map (mkDynName . addSuffix) (hsLibraries p)
+packageHsLibs dflags =
+  lookupHook packageHsLibsHook packageHsLibs' dflags dflags
+
+packageHsLibs' :: DynFlags -> PackageConfig -> [String]
+packageHsLibs' dflags p = map (mkDynName . addSuffix) (hsLibraries p)
   where
         ways0 = ways dflags
 
@@ -934,40 +848,6 @@ getPackageFrameworks dflags pkgs = do
   ps <- getPreloadPackagesAnd dflags pkgs
   return (concatMap frameworks ps)
 
--- -----------------------------------------------------------------------------
--- Package Utils
-
--- | Takes a 'Module', and if the module is in a package returns
--- @(pkgconf, exposed)@ where pkgconf is the PackageConfig for that package,
--- and exposed is @True@ if the package exposes the module.
-lookupModuleInAllPackages :: DynFlags -> ModuleName -> [(PackageConfig,Bool)]
-lookupModuleInAllPackages dflags m
-  = case lookupModuleWithSuggestions dflags m of
-      Right pbs -> pbs
-      Left  _   -> []
-
-lookupModuleWithSuggestions
-  :: DynFlags -> ModuleName
-  -> Either [Module] [(PackageConfig,Bool)]
-         -- Lookup module in all packages
-         -- Right pbs   =>   found in pbs
-         -- Left  ms    =>   not found; but here are sugestions
-lookupModuleWithSuggestions dflags m
-  = case lookupUFM (moduleToPkgConfAll pkg_state) m of
-        Nothing -> Left suggestions
-        Just ps -> Right ps
-  where
-    pkg_state = pkgState dflags
-    suggestions
-      | gopt Opt_HelpfulErrors dflags = fuzzyLookup (moduleNameString m) all_mods
-      | otherwise                     = []
-
-    all_mods :: [(String, Module)]     -- All modules
-    all_mods = [ (moduleNameString mod_nm, mkModule pkg_id mod_nm)
-               | pkg_config <- eltsUFM (pkgIdMap pkg_state)
-               , let pkg_id = packageConfigId pkg_config
-               , mod_nm <- exposedModules pkg_config ]
-
 -- | Find all the 'PackageConfig' in both the preload packages from 'DynFlags' and corresponding to the list of
 -- 'PackageConfig's
 getPreloadPackagesAnd :: DynFlags -> [PackageId] -> IO [PackageConfig]
@@ -1040,29 +920,6 @@ missingDependencyMsg (Just parent)
   = space <> parens (ptext (sLit "dependency of") <+> ftext (packageIdFS parent))
 
 -- -----------------------------------------------------------------------------
-
--- | Will the 'Name' come from a dynamically linked library?
-isDllName :: DynFlags -> PackageId -> Module -> Name -> Bool
--- Despite the "dll", I think this function just means that
--- the synbol comes from another dynamically-linked package,
--- and applies on all platforms, not just Windows
-isDllName dflags this_pkg this_mod name
-  | gopt Opt_Static dflags = False
-  | Just mod <- nameModule_maybe name
-    = if modulePackageId mod /= this_pkg
-      then True
-      else case dllSplit dflags of
-           Nothing -> False
-           Just ss ->
-               let findMod m = let modStr = moduleNameString (moduleName m)
-                               in case find (modStr `Set.member`) ss of
-                                  Just i -> i
-                                  Nothing -> panic ("Can't find " ++ modStr ++ "in DLL split")
-               in findMod mod /= findMod this_mod
-       
-  | otherwise = False  -- no, it is not even an external name
-
--- -----------------------------------------------------------------------------
 -- Displaying packages
 
 -- | Show package info on console, if verbosity is >= 3
diff --git a/compiler/main/Packages.lhs-boot b/compiler/main/Packages.lhs-boot
deleted file mode 100644
index 3a1712e..0000000
--- a/compiler/main/Packages.lhs-boot
+++ /dev/null
@@ -1,4 +0,0 @@
-\begin{code}
-module Packages where
-data PackageState
-\end{code}
diff --git a/compiler/main/SysTools.lhs b/compiler/main/SysTools.lhs
index 78255b7..9312229 100644
--- a/compiler/main/SysTools.lhs
+++ b/compiler/main/SysTools.lhs
@@ -40,8 +40,10 @@ module SysTools (
         cleanTempDirs, cleanTempFiles, cleanTempFilesExcept,
         addFilesToClean,
 
-        Option(..)
+        Option(..),
 
+        -- Hook for custom dynLib linking
+        linkDynLib'
  ) where
 
 #include "HsVersions.h"
@@ -57,6 +59,7 @@ import Platform
 import Util
 import DynFlags
 import Exception
+import Hooks
 
 import Data.IORef
 import Control.Monad
@@ -1189,7 +1192,10 @@ linesPlatform xs =
 #endif
 
 linkDynLib :: DynFlags -> [String] -> [PackageId] -> IO ()
-linkDynLib dflags0 o_files dep_packages
+linkDynLib dflags = lookupHook linkDynLibHook linkDynLib' dflags dflags
+
+linkDynLib' :: DynFlags -> [String] -> [PackageId] -> IO ()
+linkDynLib' dflags0 o_files dep_packages
  = do
     let -- This is a rather ugly hack to fix dynamically linked
         -- GHC on Windows. If GHC is linked with -threaded, then
diff --git a/compiler/main/TidyPgm.lhs b/compiler/main/TidyPgm.lhs
index 5d0cc42..830102c 100644
--- a/compiler/main/TidyPgm.lhs
+++ b/compiler/main/TidyPgm.lhs
@@ -43,7 +43,7 @@ import DataCon
 import TyCon
 import Class
 import Module
-import Packages( isDllName )
+import PackageState (isDllName)
 import HscTypes
 import Maybes
 import UniqSupply
diff --git a/compiler/stgSyn/StgSyn.lhs b/compiler/stgSyn/StgSyn.lhs
index 3fa8c68..a1dddb7 100644
--- a/compiler/stgSyn/StgSyn.lhs
+++ b/compiler/stgSyn/StgSyn.lhs
@@ -45,29 +45,29 @@ module StgSyn (
 #include "HsVersions.h"
 
 import Bitmap
-import CoreSyn     ( AltCon )
-import CostCentre  ( CostCentreStack, CostCentre )
+import CoreSyn      ( AltCon )
+import CostCentre   ( CostCentreStack, CostCentre )
 import DataCon
 import DynFlags
 import FastString
-import ForeignCall ( ForeignCall )
+import ForeignCall  ( ForeignCall )
 import Id
-import IdInfo      ( mayHaveCafRefs )
-import Literal     ( Literal, literalType )
+import IdInfo       ( mayHaveCafRefs )
+import Literal      ( Literal, literalType )
 import Module
 import Outputable
-import Packages    ( isDllName )
+import PackageState ( isDllName )
 import Platform
-import PprCore     ( {- instances -} )
-import PrimOp      ( PrimOp, PrimCall )
-import TyCon       ( PrimRep(..) )
-import TyCon       ( TyCon )
-import Type        ( Type )
-import Type        ( typePrimRep )
+import PprCore      ( {- instances -} )
+import PrimOp       ( PrimOp, PrimCall )
+import TyCon        ( PrimRep(..) )
+import TyCon        ( TyCon )
+import Type         ( Type )
+import Type         ( typePrimRep )
 import UniqSet
-import Unique      ( Unique )
+import Unique       ( Unique )
 import Util
-import VarSet      ( IdSet, isEmptyVarSet )
+import VarSet       ( IdSet, isEmptyVarSet )
 \end{code}
 
 %************************************************************************
diff --git a/compiler/typecheck/TcForeign.lhs b/compiler/typecheck/TcForeign.lhs
index d755132..963b3b8 100644
--- a/compiler/typecheck/TcForeign.lhs
+++ b/compiler/typecheck/TcForeign.lhs
@@ -13,9 +13,19 @@ module checks to see if a foreign declaration has got a legal type.
 
 \begin{code}
 module TcForeign
-        (
-          tcForeignImports
+        ( tcForeignImports
         , tcForeignExports
+
+        -- Hooks and low-level exports for hooks
+        , isForeignImport, isForeignExport
+        , tcFImport, tcFExport
+        , tcForeignImports'
+        , tcCheckFIType, checkCTarget, checkForeignArgs, checkForeignRes
+        , normaliseFfiType
+        , nonIOok, mustBeIO
+        , checkSafe, noCheckSafe
+        , tcForeignExports'
+        , tcCheckFEType
         ) where
 
 #include "HsVersions.h"
@@ -29,7 +39,7 @@ import TcEnv
 
 import FamInst
 import FamInstEnv
-import Coercion      
+import Coercion
 import Type
 import TypeRep
 import ForeignCall
@@ -47,6 +57,7 @@ import Platform
 import SrcLoc
 import Bag
 import FastString
+import Hooks
 
 import Control.Monad
 \end{code}
@@ -192,9 +203,13 @@ to the module's usages.
 
 \begin{code}
 tcForeignImports :: [LForeignDecl Name] -> TcM ([Id], [LForeignDecl Id], Bag GlobalRdrElt)
+tcForeignImports decls
+  = getHooked tcForeignImportsHook tcForeignImports' >>= ($ decls)
+
+tcForeignImports' :: [LForeignDecl Name] -> TcM ([Id], [LForeignDecl Id], Bag GlobalRdrElt)
 -- For the (Bag GlobalRdrElt) result, 
 -- see Note [Newtype constructor usage in foreign declarations]
-tcForeignImports decls
+tcForeignImports' decls
   = do { (ids, decls, gres) <- mapAndUnzip3M tcFImport $
                                filter isForeignImport decls
        ; return (ids, decls, unionManyBags gres) }
@@ -323,9 +338,14 @@ checkMissingAmpersand dflags arg_tys res_ty
 \begin{code}
 tcForeignExports :: [LForeignDecl Name]
                  -> TcM (LHsBinds TcId, [LForeignDecl TcId], Bag GlobalRdrElt)
+tcForeignExports decls =
+  getHooked tcForeignExportsHook tcForeignExports' >>= ($ decls)
+
+tcForeignExports' :: [LForeignDecl Name]
+                 -> TcM (LHsBinds TcId, [LForeignDecl TcId], Bag GlobalRdrElt)
 -- For the (Bag GlobalRdrElt) result, 
 -- see Note [Newtype constructor usage in foreign declarations]
-tcForeignExports decls
+tcForeignExports' decls
   = foldlM combine (emptyLHsBinds, [], emptyBag) (filter isForeignExport decls)
   where
    combine (binds, fs, gres1) (L loc fe) = do
diff --git a/compiler/typecheck/TcSplice.lhs b/compiler/typecheck/TcSplice.lhs
index 2528e69..7a1d355 100644
--- a/compiler/typecheck/TcSplice.lhs
+++ b/compiler/typecheck/TcSplice.lhs
@@ -12,7 +12,8 @@ module TcSplice( tcSpliceType, tcSpliceExpr, tcSpliceDecls, tcBracket,
                  lookupThName_maybe,
                  runQuasiQuoteExpr, runQuasiQuotePat,
                  runQuasiQuoteDecl, runQuasiQuoteType,
-                 runAnnotation ) where
+                 runAnnotation
+                 ) where
 
 #include "HsVersions.h"
 
@@ -721,10 +722,12 @@ runQuasiQuote (HsQuasiQuote quoter q_span quote) quote_selector meta_ty meta_ops
         ; checkTc (not is_local) (quoteStageError quoter')
 
         ; traceTc "runQQ" (ppr quoter <+> ppr is_local)
+        ; HsQuasiQuote quoter'' _ quote' <- getHooked runQuasiQuoteHook return >>=
+             ($ HsQuasiQuote quoter' q_span quote)
 
           -- Build the expression
-        ; let quoterExpr = L q_span $! HsVar $! quoter'
-        ; let quoteExpr = L q_span $! HsLit $! HsString quote
+        ; let quoterExpr = L q_span $! HsVar $! quoter''
+        ; let quoteExpr = L q_span $! HsLit $! HsString quote'
         ; let expr = L q_span $
                      HsApp (L q_span $
                             HsApp (L q_span (HsVar quote_selector)) quoterExpr) quoteExpr
